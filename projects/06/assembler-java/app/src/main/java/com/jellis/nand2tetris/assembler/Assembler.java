/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.jellis.nand2tetris.assembler;

import com.google.common.base.Strings;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

import static com.google.common.base.Preconditions.checkArgument;

public class Assembler {
    private Assembler() {}

    public static void assemble(Path asmPath, Path hackPath) {
        List<String> binary = assemble(asmPath);

        try (BufferedWriter writer = Files.newBufferedWriter(hackPath)) {
            for (String b : binary) {
                writer.write(b);
                writer.write("\n");
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    public static List<String> assemble(Path asmPath) {
        SymbolTable table = new SymbolTable();
        List<Command> commands = parse(asmPath);

        int romOffset = 0;
        for (Command command : commands) {
            switch (command) {
                case ACommand aCommand -> romOffset++;
                case CCommand cCommand -> romOffset++;
                case LCommand lCommand -> table.add(lCommand.symbol(), romOffset);
            }
        }

        List<Command> translatedCommands = commands.stream()
                .filter(c -> !(c instanceof LCommand))
                .map(c -> translate(table, c))
                .toList();

        return translatedCommands.stream().map(Command::assemble).toList();
    }

    /**
     * Converts any ACommand symbols that are not integers into their appropriate integer values.
     */
    private static Command translate(SymbolTable table, Command in) {
        return switch (in) {
            case ACommand aCommand -> {
                String symbol = aCommand.symbol();
                if (!symbol.matches("\\d+")) {
                    Integer address = table.getOrCreateVariable(symbol);
                    yield new ACommand(address.toString());
                } else {
                    yield aCommand;
                }
            }
            case CCommand cCommand -> cCommand;
            case LCommand lCommand -> throw new IllegalArgumentException("LCommands should already be processed");
        };
    }

    static List<Command> parse(Path hackPath) {
        try {
            return Files.readAllLines(hackPath).stream()
                    .map(String::trim)
                    .filter(s -> !s.isBlank())
                    .filter(s -> !s.startsWith("//"))
                    .map(Command::parse)
                    .toList();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    sealed interface Command permits ACommand, LCommand, CCommand {
        static Command parse(String command) {
            return switch (command.charAt(0)) {
                case '@' -> ACommand.parse(command);
                case '(' -> LCommand.parse(command);
                default -> CCommand.parse(command);
            };
        }

        String assemble();
    }

    record ACommand(String symbol) implements Command {
        static ACommand parse(String command) {
            checkArgument(command.charAt(0) == '@');
            return new ACommand(command.substring(1));
        }

        public String assemble() {
            String binaryString = Integer.toBinaryString(Integer.parseInt(symbol));
            int pad = 16 - binaryString.length();
            return Strings.repeat("0", pad) + binaryString;
        }
    };

    record LCommand(String symbol) implements Command {
        static LCommand parse(String command) {
            checkArgument(command.charAt(0) == '(');
            checkArgument(command.charAt(command.length() - 1) == ')');
            return new LCommand(command.substring(1, command.length() - 1));
        }

        @Override
        public String assemble() {
            throw new IllegalArgumentException("LCommands are pseudo-commands and should have already been processed");
        }
    };

    record CCommand(Dest dest, String comp, Jump jmp) implements Command {
        static CCommand parse(String command) {
            int semicolon = command.indexOf(';');
            Jump jump = semicolon == -1 ? Jump.NULL : Jump.valueOf(command.substring(semicolon + 1));

            String destAndComp = command.substring(0, semicolon == -1 ? command.length() : semicolon);

            int equals = destAndComp.indexOf('=');
            Dest dest = equals == -1 ? Dest.NULL : Dest.valueOf(destAndComp.substring(0, equals));

            String comp = destAndComp.substring(equals == -1 ? 0 : equals + 1);

            return new CCommand(dest, comp, jump);
        }

        @Override
        public String assemble() {
            String a = comp.contains("M") ? "1" : "0";
            String compBits = switch (comp) {
                case          "0" -> "101010";
                case          "1" -> "111111";
                case         "-1" -> "111010";
                case          "D" -> "001100";
                case     "A", "M" -> "110000";
                case         "!D" -> "001101";
                case   "!A", "!M" -> "110001";
                case         "-D" -> "001111";
                case   "-A", "-M" -> "110011";
                case        "D+1" -> "011111";
                case "A+1", "M+1" -> "110111";
                case        "D-1" -> "001110";
                case "A-1", "M-1" -> "110010";
                case "D+A", "D+M" -> "000010";
                case "D-A", "D-M" -> "010011";
                case "A-D", "M-D" -> "000111";
                case "D&A", "D&M" -> "000000";
                case "D|A", "D|M" -> "010101";
                default -> throw new IllegalStateException("Unexpected value: " + comp);
            };
            return "111" + a + compBits + dest.binary() + jmp.binary();
        }
    }

    enum Jump {
        NULL("000"), JGT("001"), JEQ("010"), JGE("011"),
        JLT("100"), JNE("101"), JLE("110"), JMP("111");

        private final String binary;

        Jump(String binary) {
            this.binary = binary;
        }
        public String binary() {
            return binary;
        }
    }

    enum Dest {
        NULL("000"), M("001"), D("010"), MD("011"),
        A("100"), AM("101"), AD("110"), AMD("111");

        private final String binary;

        Dest(String binary) {
            this.binary = binary;
        }

        public String binary() {
            return binary;
        }
    }
}
